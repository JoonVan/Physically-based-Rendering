#include "ImGuiHandler.h"

using std::vector;


static unsigned char __glsl_shader_vert_spv[] = {
	0x03, 0x02, 0x23, 0x07, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x08, 0x00,
	0x6c, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x02, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x11, 0x00, 0x02, 0x00, 0x20, 0x00, 0x00, 0x00,
	0x11, 0x00, 0x02, 0x00, 0x21, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x06, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x47, 0x4c, 0x53, 0x4c, 0x2e, 0x73, 0x74, 0x64,
	0x2e, 0x34, 0x35, 0x30, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x03, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x0a, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x1f, 0x16, 0x00, 0x00, 0x6d, 0x61, 0x69, 0x6e,
	0x00, 0x00, 0x00, 0x00, 0x47, 0x11, 0x00, 0x00, 0x41, 0x14, 0x00, 0x00,
	0x6a, 0x16, 0x00, 0x00, 0x42, 0x13, 0x00, 0x00, 0x80, 0x14, 0x00, 0x00,
	0x47, 0x00, 0x03, 0x00, 0x1a, 0x04, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x47, 0x00, 0x04, 0x00, 0x41, 0x14, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00,
	0x02, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 0x6a, 0x16, 0x00, 0x00,
	0x1e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x48, 0x00, 0x05, 0x00,
	0xb1, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x05, 0x00, 0xb1, 0x02, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x48, 0x00, 0x05, 0x00, 0xb1, 0x02, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x0b, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x48, 0x00, 0x05, 0x00,
	0xb1, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00,
	0x04, 0x00, 0x00, 0x00, 0x47, 0x00, 0x03, 0x00, 0xb1, 0x02, 0x00, 0x00,
	0x02, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 0x80, 0x14, 0x00, 0x00,
	0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x05, 0x00,
	0x06, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x05, 0x00, 0x06, 0x04, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
	0x47, 0x00, 0x03, 0x00, 0x06, 0x04, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x47, 0x00, 0x04, 0x00, 0xfa, 0x16, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x02, 0x00, 0x08, 0x00, 0x00, 0x00,
	0x21, 0x00, 0x03, 0x00, 0x02, 0x05, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
	0x16, 0x00, 0x03, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
	0x17, 0x00, 0x04, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00,
	0x04, 0x00, 0x00, 0x00, 0x17, 0x00, 0x04, 0x00, 0x13, 0x00, 0x00, 0x00,
	0x0d, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x04, 0x00,
	0x1a, 0x04, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
	0x20, 0x00, 0x04, 0x00, 0x97, 0x06, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
	0x1a, 0x04, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x97, 0x06, 0x00, 0x00,
	0x47, 0x11, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x15, 0x00, 0x04, 0x00,
	0x0c, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x2b, 0x00, 0x04, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x0b, 0x0a, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x9a, 0x02, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00,
	0x9a, 0x02, 0x00, 0x00, 0x41, 0x14, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x20, 0x00, 0x04, 0x00, 0x9b, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
	0x1d, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00, 0x0c, 0x00, 0x00, 0x00,
	0x0e, 0x0a, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00,
	0x90, 0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
	0x3b, 0x00, 0x04, 0x00, 0x90, 0x02, 0x00, 0x00, 0x6a, 0x16, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x91, 0x02, 0x00, 0x00,
	0x03, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x15, 0x00, 0x04, 0x00,
	0x0b, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2b, 0x00, 0x04, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x0d, 0x0a, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x04, 0x00, 0x7f, 0x02, 0x00, 0x00,
	0x0d, 0x00, 0x00, 0x00, 0x0d, 0x0a, 0x00, 0x00, 0x1e, 0x00, 0x06, 0x00,
	0xb1, 0x02, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00,
	0x7f, 0x02, 0x00, 0x00, 0x7f, 0x02, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00,
	0x2e, 0x05, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xb1, 0x02, 0x00, 0x00,
	0x3b, 0x00, 0x04, 0x00, 0x2e, 0x05, 0x00, 0x00, 0x42, 0x13, 0x00, 0x00,
	0x03, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x90, 0x02, 0x00, 0x00,
	0x80, 0x14, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x04, 0x00,
	0x06, 0x04, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
	0x20, 0x00, 0x04, 0x00, 0x83, 0x06, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
	0x06, 0x04, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x83, 0x06, 0x00, 0x00,
	0xfa, 0x16, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00,
	0x92, 0x02, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
	0x2b, 0x00, 0x04, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x0c, 0x0a, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00, 0x0d, 0x00, 0x00, 0x00,
	0x8a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x36, 0x00, 0x05, 0x00,
	0x08, 0x00, 0x00, 0x00, 0x1f, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x05, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00, 0x6b, 0x60, 0x00, 0x00,
	0x3d, 0x00, 0x04, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x71, 0x4e, 0x00, 0x00,
	0x41, 0x14, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00, 0x9b, 0x02, 0x00, 0x00,
	0xaa, 0x26, 0x00, 0x00, 0x47, 0x11, 0x00, 0x00, 0x0b, 0x0a, 0x00, 0x00,
	0x3e, 0x00, 0x03, 0x00, 0xaa, 0x26, 0x00, 0x00, 0x71, 0x4e, 0x00, 0x00,
	0x3d, 0x00, 0x04, 0x00, 0x13, 0x00, 0x00, 0x00, 0xda, 0x35, 0x00, 0x00,
	0x6a, 0x16, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00, 0x91, 0x02, 0x00, 0x00,
	0xea, 0x50, 0x00, 0x00, 0x47, 0x11, 0x00, 0x00, 0x0e, 0x0a, 0x00, 0x00,
	0x3e, 0x00, 0x03, 0x00, 0xea, 0x50, 0x00, 0x00, 0xda, 0x35, 0x00, 0x00,
	0x3d, 0x00, 0x04, 0x00, 0x13, 0x00, 0x00, 0x00, 0xc7, 0x35, 0x00, 0x00,
	0x80, 0x14, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00, 0x92, 0x02, 0x00, 0x00,
	0xef, 0x56, 0x00, 0x00, 0xfa, 0x16, 0x00, 0x00, 0x0b, 0x0a, 0x00, 0x00,
	0x3d, 0x00, 0x04, 0x00, 0x13, 0x00, 0x00, 0x00, 0xe0, 0x29, 0x00, 0x00,
	0xef, 0x56, 0x00, 0x00, 0x85, 0x00, 0x05, 0x00, 0x13, 0x00, 0x00, 0x00,
	0xa0, 0x22, 0x00, 0x00, 0xc7, 0x35, 0x00, 0x00, 0xe0, 0x29, 0x00, 0x00,
	0x41, 0x00, 0x05, 0x00, 0x92, 0x02, 0x00, 0x00, 0x42, 0x2c, 0x00, 0x00,
	0xfa, 0x16, 0x00, 0x00, 0x0e, 0x0a, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
	0x13, 0x00, 0x00, 0x00, 0x09, 0x60, 0x00, 0x00, 0x42, 0x2c, 0x00, 0x00,
	0x81, 0x00, 0x05, 0x00, 0x13, 0x00, 0x00, 0x00, 0xd1, 0x4e, 0x00, 0x00,
	0xa0, 0x22, 0x00, 0x00, 0x09, 0x60, 0x00, 0x00, 0x51, 0x00, 0x05, 0x00,
	0x0d, 0x00, 0x00, 0x00, 0xa1, 0x41, 0x00, 0x00, 0xd1, 0x4e, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x51, 0x00, 0x05, 0x00, 0x0d, 0x00, 0x00, 0x00,
	0x84, 0x36, 0x00, 0x00, 0xd1, 0x4e, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x50, 0x00, 0x07, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x54, 0x47, 0x00, 0x00,
	0xa1, 0x41, 0x00, 0x00, 0x84, 0x36, 0x00, 0x00, 0x0c, 0x0a, 0x00, 0x00,
	0x8a, 0x00, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00, 0x9b, 0x02, 0x00, 0x00,
	0x17, 0x2f, 0x00, 0x00, 0x42, 0x13, 0x00, 0x00, 0x0b, 0x0a, 0x00, 0x00,
	0x3e, 0x00, 0x03, 0x00, 0x17, 0x2f, 0x00, 0x00, 0x54, 0x47, 0x00, 0x00,
	0xfd, 0x00, 0x01, 0x00, 0x38, 0x00, 0x01, 0x00
};

static unsigned int __glsl_shader_vert_spv_len = 1172;

static unsigned char __glsl_shader_frag_spv[] = {
	0x03, 0x02, 0x23, 0x07, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x08, 0x00,
	0x6c, 0x5d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x02, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x47, 0x4c, 0x53, 0x4c, 0x2e, 0x73, 0x74, 0x64, 0x2e, 0x34, 0x35, 0x30,
	0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x07, 0x00, 0x04, 0x00, 0x00, 0x00,
	0x1f, 0x16, 0x00, 0x00, 0x6d, 0x61, 0x69, 0x6e, 0x00, 0x00, 0x00, 0x00,
	0x7a, 0x0c, 0x00, 0x00, 0x35, 0x16, 0x00, 0x00, 0x10, 0x00, 0x03, 0x00,
	0x1f, 0x16, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00,
	0x7a, 0x0c, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x47, 0x00, 0x04, 0x00, 0x7a, 0x0c, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x03, 0x00, 0x1a, 0x04, 0x00, 0x00,
	0x02, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 0xec, 0x14, 0x00, 0x00,
	0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00,
	0xec, 0x14, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x13, 0x00, 0x02, 0x00, 0x08, 0x00, 0x00, 0x00, 0x21, 0x00, 0x03, 0x00,
	0x02, 0x05, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x16, 0x00, 0x03, 0x00,
	0x0d, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x17, 0x00, 0x04, 0x00,
	0x1d, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
	0x20, 0x00, 0x04, 0x00, 0x9a, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
	0x1d, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x9a, 0x02, 0x00, 0x00,
	0x7a, 0x0c, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x17, 0x00, 0x04, 0x00,
	0x13, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x1e, 0x00, 0x04, 0x00, 0x1a, 0x04, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00,
	0x13, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x97, 0x06, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x1a, 0x04, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00,
	0x97, 0x06, 0x00, 0x00, 0x35, 0x16, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x15, 0x00, 0x04, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00, 0x0c, 0x00, 0x00, 0x00,
	0x0b, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00,
	0x9b, 0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00,
	0x19, 0x00, 0x09, 0x00, 0x96, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1b, 0x00, 0x03, 0x00, 0xfe, 0x01, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00,
	0x20, 0x00, 0x04, 0x00, 0x7b, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xfe, 0x01, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x7b, 0x04, 0x00, 0x00,
	0xec, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00,
	0x0c, 0x00, 0x00, 0x00, 0x0e, 0x0a, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x20, 0x00, 0x04, 0x00, 0x90, 0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x13, 0x00, 0x00, 0x00, 0x36, 0x00, 0x05, 0x00, 0x08, 0x00, 0x00, 0x00,
	0x1f, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x05, 0x00, 0x00,
	0xf8, 0x00, 0x02, 0x00, 0x6b, 0x5d, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00,
	0x9b, 0x02, 0x00, 0x00, 0x8d, 0x1b, 0x00, 0x00, 0x35, 0x16, 0x00, 0x00,
	0x0b, 0x0a, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x1d, 0x00, 0x00, 0x00,
	0x0b, 0x40, 0x00, 0x00, 0x8d, 0x1b, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
	0xfe, 0x01, 0x00, 0x00, 0xc0, 0x36, 0x00, 0x00, 0xec, 0x14, 0x00, 0x00,
	0x41, 0x00, 0x05, 0x00, 0x90, 0x02, 0x00, 0x00, 0xc2, 0x43, 0x00, 0x00,
	0x35, 0x16, 0x00, 0x00, 0x0e, 0x0a, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
	0x13, 0x00, 0x00, 0x00, 0x02, 0x4e, 0x00, 0x00, 0xc2, 0x43, 0x00, 0x00,
	0x57, 0x00, 0x05, 0x00, 0x1d, 0x00, 0x00, 0x00, 0xb9, 0x46, 0x00, 0x00,
	0xc0, 0x36, 0x00, 0x00, 0x02, 0x4e, 0x00, 0x00, 0x85, 0x00, 0x05, 0x00,
	0x1d, 0x00, 0x00, 0x00, 0xe4, 0x23, 0x00, 0x00, 0x0b, 0x40, 0x00, 0x00,
	0xb9, 0x46, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x7a, 0x0c, 0x00, 0x00,
	0xe4, 0x23, 0x00, 0x00, 0xfd, 0x00, 0x01, 0x00, 0x38, 0x00, 0x01, 0x00
};

static unsigned int __glsl_shader_frag_spv_len = 660;


/**
 * Bind the render data.
 */
void ImGuiHandler::bindRenderData() {
	vkCmdBindPipeline(
		mCommandBuffers[mVH->mFrameIndex],
		VK_PIPELINE_BIND_POINT_GRAPHICS,
		mGraphicsPipeline
	);

	VkDescriptorSet descSet[1] = { mDescriptorSet };

	vkCmdBindDescriptorSets(
		mCommandBuffers[mVH->mFrameIndex],
		VK_PIPELINE_BIND_POINT_GRAPHICS,
		mPipelineLayout, 0, 1,
		descSet, 0, NULL
	);

	VkBuffer vertexBuffers[1] = { mVertexBuffer };
	VkDeviceSize vertexOffset[1] = { 0 };

	vkCmdBindVertexBuffers(
		mCommandBuffers[mVH->mFrameIndex],
		0, 1,
		vertexBuffers, vertexOffset
	);

	vkCmdBindIndexBuffer(
		mCommandBuffers[mVH->mFrameIndex],
		mIndexBuffer,
		0, VK_INDEX_TYPE_UINT16
	);
}


/**
 * Create everything descriptor related for ImGui.
 */
void ImGuiHandler::createDescriptors() {
	VkResult result;

	// Layout.

	VkSampler sampler[1] = { mFontSampler };

	VkDescriptorSetLayoutBinding binding[1] = {};
	binding[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
	binding[0].descriptorCount = 1;
	binding[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
	binding[0].pImmutableSamplers = sampler;

	VkDescriptorSetLayoutCreateInfo info = {};
	info.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
	info.bindingCount = 1;
	info.pBindings = binding;

	result = vkCreateDescriptorSetLayout(
		mVH->mLogicalDevice, &info, nullptr, &mDescriptorSetLayout
	);
	VulkanHandler::checkVkResult(
		result, "Failed to create VkDescriptorSetLayout.", "ImGuiHandler"
	);

	// Set.

	VkDescriptorSetAllocateInfo allocInfo = {};
	allocInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
	allocInfo.descriptorPool = mVH->mDescriptorPool;
	allocInfo.descriptorSetCount = 1;
	allocInfo.pSetLayouts = &mDescriptorSetLayout;

	result = vkAllocateDescriptorSets(
		mVH->mLogicalDevice, &allocInfo, &mDescriptorSet
	);
	VulkanHandler::checkVkResult(
		result, "Failed to allocate descriptor set.", "ImGuiHandler"
	);
}


/**
 * Create the ImGui shader modules.
 */
void ImGuiHandler::createShaders( VkShaderModule* vertModule, VkShaderModule* fragModule ) {
	VkResult result;

	VkShaderModuleCreateInfo vertInfo = {};
	vertInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
	vertInfo.codeSize = __glsl_shader_vert_spv_len;
	vertInfo.pCode = (uint32_t*) __glsl_shader_vert_spv;

	result = vkCreateShaderModule( mVH->mLogicalDevice, &vertInfo, nullptr, vertModule );
	VulkanHandler::checkVkResult(
		result, "Failed to create vertex shader module.", "ImGuiHandler"
	);

	VkShaderModuleCreateInfo fragInfo = {};
	fragInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
	fragInfo.codeSize = __glsl_shader_frag_spv_len;
	fragInfo.pCode = (uint32_t*) __glsl_shader_frag_spv;

	result = vkCreateShaderModule( mVH->mLogicalDevice, &fragInfo, nullptr, fragModule );
	VulkanHandler::checkVkResult(
		result, "Failed to create fragment shader module.", "ImGuiHandler"
	);
}


/**
 * Draw the ImGui.
 */
void ImGuiHandler::draw() {
	// TODO: ImGui setup, update, draw.
	// ImGui::Text( "Hello, world!" );
}


/**
 * Call the actual draw commands.
 * @param {ImDrawData*} drawData
 */
void ImGuiHandler::drawImGuiData( ImDrawData* drawData ) {
	ImGuiIO& io = ImGui::GetIO();

	VkViewport viewport;
	viewport.x = 0;
	viewport.y = 0;
	viewport.width = io.DisplaySize.x;
	viewport.height = io.DisplaySize.y;
	viewport.minDepth = 0.0f;
	viewport.maxDepth = 1.0f;
	vkCmdSetViewport( mCommandBuffers[mVH->mFrameIndex], 0, 1, &viewport );

	// Scale and translation.
	float scale[2] = {
		2.0f / io.DisplaySize.x,
		2.0f / io.DisplaySize.y
	};
	float translate[2] = { -1.0f, -1.0f };

	vkCmdPushConstants(
		mCommandBuffers[mVH->mFrameIndex],
		mPipelineLayout,
		VK_SHADER_STAGE_VERTEX_BIT,
		sizeof( float ) * 0,
		sizeof( float ) * 2,
		scale
	);
	vkCmdPushConstants(
		mCommandBuffers[mVH->mFrameIndex],
		mPipelineLayout,
		VK_SHADER_STAGE_VERTEX_BIT,
		sizeof( float ) * 2,
		sizeof( float ) * 2,
		translate
	);

	int vertexOffset = 0;
	int indexOffset = 0;

	for( int i = 0; i < drawData->CmdListsCount; i++ ) {
		const ImDrawList* cmdList = drawData->CmdLists[i];

		for( int j = 0; j < cmdList->CmdBuffer.Size; j++ ) {
			const ImDrawCmd* pCmd = &cmdList->CmdBuffer[j];

			if( pCmd->UserCallback ) {
				pCmd->UserCallback( cmdList, pCmd );
			}
			else {
				VkRect2D scissor;
				scissor.offset.x = (int32_t) pCmd->ClipRect.x;
				scissor.offset.y = (int32_t) pCmd->ClipRect.y;
				scissor.extent.width = (uint32_t) ( pCmd->ClipRect.z - pCmd->ClipRect.x );
				scissor.extent.height = (uint32_t) ( pCmd->ClipRect.w - pCmd->ClipRect.y );

				vkCmdSetScissor(
					mCommandBuffers[mVH->mFrameIndex],
					0, 1, &scissor
				);
				vkCmdDrawIndexed(
					mCommandBuffers[mVH->mFrameIndex],
					pCmd->ElemCount, 1,
					indexOffset, vertexOffset, 0
				);
			}

			indexOffset += pCmd->ElemCount;
		}

		vertexOffset += cmdList->VtxBuffer.Size;
	}
}


/**
 * Get the clipboard text.
 * @return {const char*}
 */
const char* ImGuiHandler::getClipboardText() {
	return glfwGetClipboardString( mVH->mWindow );
}


/**
 * ImGui draw function.
 * @param {ImDrawData*} drawData
 */
void ImGuiHandler::renderDrawList( ImDrawData* drawData ) {
	size_t verticesSize = this->updateVertexBuffer( drawData );
	size_t indicesSize = this->updateIndexBuffer( drawData );
	this->uploadRenderData( drawData, verticesSize, indicesSize );
	this->bindRenderData();
	this->drawImGuiData( drawData );
}


/**
 * Set the clipboard text.
 * @param {const char*} text
 */
void ImGuiHandler::setClipboardText( const char* text ) {
	glfwSetClipboardString( mVH->mWindow, text );
}


/**
 * Setup ImGui with Vulkan.
 * @param {VulkanHandler*} vh
 */
void ImGuiHandler::setup( VulkanHandler* vh ) {
	mVH = vh;

	VkShaderModule vertModule;
	VkShaderModule fragModule;

	this->createShaders( &vertModule, &fragModule );
	this->setupFontSampler();
	this->createDescriptors();

	vkDestroyShaderModule( mVH->mLogicalDevice, vertModule, nullptr );
	vkDestroyShaderModule( mVH->mLogicalDevice, fragModule, nullptr );

	ImGuiIO& io = ImGui::GetIO();
	io.KeyMap[ImGuiKey_Tab] = GLFW_KEY_TAB;
	io.KeyMap[ImGuiKey_LeftArrow] = GLFW_KEY_LEFT;
	io.KeyMap[ImGuiKey_RightArrow] = GLFW_KEY_RIGHT;
	io.KeyMap[ImGuiKey_UpArrow] = GLFW_KEY_UP;
	io.KeyMap[ImGuiKey_DownArrow] = GLFW_KEY_DOWN;
	io.KeyMap[ImGuiKey_PageUp] = GLFW_KEY_PAGE_UP;
	io.KeyMap[ImGuiKey_PageDown] = GLFW_KEY_PAGE_DOWN;
	io.KeyMap[ImGuiKey_Home] = GLFW_KEY_HOME;
	io.KeyMap[ImGuiKey_End] = GLFW_KEY_END;
	io.KeyMap[ImGuiKey_Delete] = GLFW_KEY_DELETE;
	io.KeyMap[ImGuiKey_Backspace] = GLFW_KEY_BACKSPACE;
	io.KeyMap[ImGuiKey_Enter] = GLFW_KEY_ENTER;
	io.KeyMap[ImGuiKey_Escape] = GLFW_KEY_ESCAPE;
	io.KeyMap[ImGuiKey_A] = GLFW_KEY_A;
	io.KeyMap[ImGuiKey_C] = GLFW_KEY_C;
	io.KeyMap[ImGuiKey_V] = GLFW_KEY_V;
	io.KeyMap[ImGuiKey_X] = GLFW_KEY_X;
	io.KeyMap[ImGuiKey_Y] = GLFW_KEY_Y;
	io.KeyMap[ImGuiKey_Z] = GLFW_KEY_Z;

	io.RenderDrawListsFn = ( void (*)( ImDrawData* ) ) &ImGuiHandler::renderDrawList;
	io.SetClipboardTextFn = ( void (*)( const char* ) ) &ImGuiHandler::setClipboardText;
	io.GetClipboardTextFn = ( const char* (*)() ) &ImGuiHandler::getClipboardText;

	Logger::logDebug( "[ImGuiHandler] Setup done." );
}


/**
 * Setup ImGui font sampler.
 */
void ImGuiHandler::setupFontSampler() {
	VkSamplerCreateInfo samplerInfo = {};
	samplerInfo.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
	samplerInfo.magFilter = VK_FILTER_LINEAR;
	samplerInfo.minFilter = VK_FILTER_LINEAR;
	samplerInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;
	samplerInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT;
	samplerInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT;
	samplerInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT;
	samplerInfo.minLod = -1000;
	samplerInfo.maxLod = 1000;

	VkResult result = vkCreateSampler(
		mVH->mLogicalDevice, &samplerInfo, nullptr, &mFontSampler
	);
	VulkanHandler::checkVkResult(
		result, "Failed to create sampler.", "ImGuiHandler"
	);
}


/**
 * Teardown ImGui.
 */
void ImGuiHandler::teardown() {
	if( mDescriptorSetLayout != VK_NULL_HANDLE ) {
		vkDestroyDescriptorSetLayout( mVH->mLogicalDevice, mDescriptorSetLayout, nullptr );
		mDescriptorSetLayout = VK_NULL_HANDLE;
		Logger::logDebugVerbose( "[ImGuiHandler] VkDescriptorSetLayout destroyed." );
	}

	if( mFontSampler != VK_NULL_HANDLE ) {
		vkDestroySampler( mVH->mLogicalDevice, mFontSampler, nullptr );
		mFontSampler = VK_NULL_HANDLE;
		Logger::logDebugVerbose( "[ImGuiHandler] VkSampler (font) destroyed." );
	}

	if( mVertexBufferMemory != VK_NULL_HANDLE ) {
		vkFreeMemory( mVH->mLogicalDevice, mVertexBufferMemory, nullptr );
		mVertexBufferMemory = VK_NULL_HANDLE;
		Logger::logDebugVerbose( "[ImGuiHandler] VkDeviceMemory (vertices) freed." );
	}

	if( mVertexBuffer != VK_NULL_HANDLE ) {
		vkDestroyBuffer( mVH->mLogicalDevice, mVertexBuffer, nullptr );
		mVertexBuffer = VK_NULL_HANDLE;
		Logger::logDebugVerbose( "[ImGuiHandler] VkBuffer (vertices) destroyed." );
	}
}


/**
 * Update the index buffer.
 * @param  {ImDrawData*} drawData
 * @return {size_t}
 */
size_t ImGuiHandler::updateIndexBuffer( ImDrawData* drawData ) {
	VkResult result;
	size_t indicesSize = drawData->TotalIdxCount * sizeof( ImDrawIdx );

	if( mIndexBuffer != VK_NULL_HANDLE ) {
		vkDestroyBuffer( mVH->mLogicalDevice, mIndexBuffer, nullptr );
	}

	if( mIndexBufferMemory != VK_NULL_HANDLE ) {
		vkFreeMemory( mVH->mLogicalDevice, mIndexBufferMemory, nullptr );
	}

	VkBufferCreateInfo bufferInfo = {};
	bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
	bufferInfo.size = indicesSize;
	bufferInfo.usage = VK_BUFFER_USAGE_INDEX_BUFFER_BIT;
	bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

	result = vkCreateBuffer(
		mVH->mLogicalDevice, &bufferInfo, nullptr, &mIndexBuffer
	);
	VulkanHandler::checkVkResult(
		result, "Failed to create index buffer.", "ImGuiHandler"
	);

	VkMemoryRequirements memReq;
	vkGetBufferMemoryRequirements(
		mVH->mLogicalDevice, mIndexBuffer, &memReq
	);

	VkMemoryAllocateInfo allocInfo = {};
	allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
	allocInfo.allocationSize = memReq.size;
	allocInfo.memoryTypeIndex = mVH->findMemoryType(
		memReq.memoryTypeBits,
		VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT
	);

	result = vkAllocateMemory(
		mVH->mLogicalDevice, &allocInfo, nullptr, &mIndexBufferMemory
	);
	VulkanHandler::checkVkResult(
		result, "Failed to allocate index memory.", "ImGuiHandler"
	);

	result = vkBindBufferMemory(
		mVH->mLogicalDevice,
		mIndexBuffer,
		mIndexBufferMemory,
		0
	);
	VulkanHandler::checkVkResult(
		result, "Failed to bind index buffer memory.", "ImGuiHandler"
	);

	return indicesSize;
}


/**
 * Update the vertex buffer.
 * @param  {ImDrawData*} drawData
 * @return {size_t}
 */
size_t ImGuiHandler::updateVertexBuffer( ImDrawData* drawData ) {
	VkResult result;
	size_t verticesSize = drawData->TotalVtxCount * sizeof( ImDrawVert );

	if( mVertexBuffer != VK_NULL_HANDLE ) {
		vkDestroyBuffer( mVH->mLogicalDevice, mVertexBuffer, nullptr );
	}

	if( mVertexBufferMemory != VK_NULL_HANDLE ) {
		vkFreeMemory( mVH->mLogicalDevice, mVertexBufferMemory, nullptr );
	}

	VkBufferCreateInfo bufferInfo = {};
	bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
	bufferInfo.size = verticesSize;
	bufferInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
	bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

	result = vkCreateBuffer(
		mVH->mLogicalDevice, &bufferInfo, nullptr, &mVertexBuffer
	);
	VulkanHandler::checkVkResult(
		result, "Failed to create vertex buffer.", "ImGuiHandler"
	);

	VkMemoryRequirements memReq;
	vkGetBufferMemoryRequirements(
		mVH->mLogicalDevice, mVertexBuffer, &memReq
	);

	VkMemoryAllocateInfo allocInfo = {};
	allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
	allocInfo.allocationSize = memReq.size;
	allocInfo.memoryTypeIndex = mVH->findMemoryType(
		memReq.memoryTypeBits,
		VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT
	);

	result = vkAllocateMemory(
		mVH->mLogicalDevice, &allocInfo, nullptr, &mVertexBufferMemory
	);
	VulkanHandler::checkVkResult(
		result, "Failed to allocate vertex memory.", "ImGuiHandler"
	);

	result = vkBindBufferMemory(
		mVH->mLogicalDevice,
		mVertexBuffer,
		mVertexBufferMemory,
		0
	);
	VulkanHandler::checkVkResult(
		result, "Failed to bind vertex buffer memory.", "ImGuiHandler"
	);

	return verticesSize;
}


/**
 * Upload the buffer data.
 * @param {ImDrawData*} drawData
 * @param {size_t}      verticesSize
 * @param {size_t}      indicesSize
 */
void ImGuiHandler::uploadRenderData(
	ImDrawData* drawData, size_t verticesSize, size_t indicesSize
) {
	VkResult result;
	ImDrawVert* vertexDst;
	ImDrawIdx* indexDst;

	result = vkMapMemory(
		mVH->mLogicalDevice,
		mVertexBufferMemory,
		0, verticesSize, 0,
		( void** )( &vertexDst )
	);
	VulkanHandler::checkVkResult(
		result, "Failed to map vertex memory.", "ImGuiHandler"
	);

	result = vkMapMemory(
		mVH->mLogicalDevice,
		mIndexBufferMemory,
		0, indicesSize, 0,
		( void** )( &indexDst )
	);
	VulkanHandler::checkVkResult(
		result, "Failed to map index memory.", "ImGuiHandler"
	);

	for( int i = 0; i < drawData->CmdListsCount; i++ ) {
		const ImDrawList* cmdList = drawData->CmdLists[i];
		memcpy(
			vertexDst,
			cmdList->VtxBuffer.Data,
			cmdList->VtxBuffer.Size * sizeof( ImDrawVert )
		);
		memcpy(
			indexDst,
			cmdList->IdxBuffer.Data,
			cmdList->IdxBuffer.Size * sizeof( ImDrawIdx )
		);
		vertexDst += cmdList->VtxBuffer.Size;
		indexDst += cmdList->IdxBuffer.Size;
	}

	VkMappedMemoryRange range[2] = {};
	range[0].sType = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
	range[0].memory = mVertexBufferMemory;
	range[0].size = verticesSize;
	range[1].sType = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
	range[1].memory = mIndexBufferMemory;
	range[1].size = indicesSize;

	result = vkFlushMappedMemoryRanges( mVH->mLogicalDevice, 2, range );
	VulkanHandler::checkVkResult(
		result, "Failed to flush mapped memory ranges.", "ImGuiHandler"
	);

	vkUnmapMemory( mVH->mLogicalDevice, mVertexBufferMemory );
	vkUnmapMemory( mVH->mLogicalDevice, mIndexBufferMemory );
}
